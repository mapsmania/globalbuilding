<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Power Grid Routing Puzzle (Fixed Centroid & Projection)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://unpkg.com/maplibre-gl@3.4.0/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/maplibre-gl@3.4.0/dist/maplibre-gl.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>

<style>
    body { margin: 0; padding: 0; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }

    #hud { 
        position: absolute; 
        top: 10px; 
        left: 10px; 
        background: rgba(0,0,0,0.75); 
        color: white; 
        padding: 14px; 
        border-radius: 8px;
        z-index: 10;
        font-family: sans-serif;
    }
    #hud h2 { margin-top: 0; font-size: 1.2em; }
    #hud p { margin: 5px 0; font-size: 1em; }
</style>
</head>

<body>

<div id="hud">
    <h2>âš¡ Power Grid Puzzle</h2>
    <p>Connected Buildings: <span id="connected-count">0</span> / <span id="total-buildings">0</span></p>
    <p>Cable Used: <span id="used-cable">0</span> m</p>
    <p>Cable Budget: <span id="budget-remaining">0</span> m</p>
    <p id="game-status"></p>
</div>

<div id="map"></div>

<script>
/* ---------------------- Config ---------------------- */
const POWER_LAYER_ID = 'buildings-3d';
const POWER_COLORS = { ON: "#FFFFB3", OFF: "#1A1A1A" };
const DEFAULT_COLOR = "#888888";

const CABLE_BUDGET = 10000;
const MAX_JUMP_DISTANCE = 500;

/* ---------------------- State ----------------------- */
let totalBuildingsCount = 0;
let reprojectedFeatures = [];
let powerSourceID = null;
let currentConnectionTargetID = null;
let usedCableLength = 0;

const buildingPowerStates = {};
const connectedBuildingIDs = new Set();

const powerLineGeometry = { 
    type: "FeatureCollection",
    features: []
};

/* ---------------------- Projection ------------------- */

function reprojectCoord(coord) {
    return proj4("EPSG:3857", "EPSG:4326", coord);
}

function reprojectGeometry(geom) {
    if (geom.type === "Polygon") {
        return {
            type: "Polygon",
            coordinates: geom.coordinates.map(
                ring => ring.map(reprojectCoord)
            )
        };
    }
    if (geom.type === "MultiPolygon") {
        return {
            type: "MultiPolygon",
            coordinates: geom.coordinates.map(poly =>
                poly.map(ring => ring.map(reprojectCoord))
            )
        };
    }
    return geom;
}

/* ---------------------- Centroid (FIXED!) ---------------------- */

function getConnectionCoordinates(feature) {
    if (!feature || !feature.geometry) return null;

    let coords = feature.geometry.coordinates;

    if (feature.geometry.type === "Polygon") {
        coords = coords[0];
    }
    else if (feature.geometry.type === "MultiPolygon") {
        coords = coords[0][0];
    }
    else {
        return null;
    }

    if (!coords || coords.length < 3) {
        console.warn("Invalid polygon, using first coordinate", feature);
        const [lng, lat] = coords[0] || [0, 0];
        return { lng, lat };
    }

    // Polygon centroid formula
    let area = 0, cx = 0, cy = 0;

    for (let i = 0, j = coords.length - 1; i < coords.length; j = i++) {
        const [x1, y1] = coords[j];
        const [x2, y2] = coords[i];

        const f = x1 * y2 - x2 * y1;
        area += f;
        cx += (x1 + x2) * f;
        cy += (y1 + y2) * f;
    }

    area *= 0.5;

    if (area === 0) {
        const [lng, lat] = coords[0];
        return { lng, lat };
    }

    return {
        lng: cx / (6 * area),
        lat: cy / (6 * area)
    };
}

/* ---------------------- Distance ---------------------- */

function calculateDistance(c1, c2) {
    if (!c1 || !c2) return Infinity;

    const R = 6371000;
    const dLat = (c2.lat - c1.lat) * Math.PI / 180;
    const dLon = (c2.lng - c1.lng) * Math.PI / 180;

    const a =
        Math.sin(dLat/2)**2 +
        Math.cos(c1.lat*Math.PI/180) *
        Math.cos(c2.lat*Math.PI/180) *
        Math.sin(dLon/2)**2;

    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

/* ---------------------- HUD ---------------------- */

function updateGameHUD(message = "") {
    const remaining = CABLE_BUDGET - usedCableLength;

    document.getElementById("connected-count").innerText = connectedBuildingIDs.size;
    document.getElementById("total-buildings").innerText = totalBuildingsCount;
    document.getElementById("used-cable").innerText = usedCableLength.toFixed(0);
    document.getElementById("budget-remaining").innerText = remaining.toFixed(0);
    document.getElementById("game-status").innerText = message;
}

/* ---------------------- Game Setup ---------------------- */

function initializePowerStates(features) {
    totalBuildingsCount = features.length;
    features.forEach(f => buildingPowerStates[f.properties.id] = "OFF");

    const startIndex = Math.floor(Math.random() * features.length);
    const src = features[startIndex];

    powerSourceID = src.properties.id;
    currentConnectionTargetID = powerSourceID;

    buildingPowerStates[powerSourceID] = "ON";
    connectedBuildingIDs.add(powerSourceID);
}

function updateBuildingColors() {
    const colorExpr = ["match", ["get", "id"]];

    for (const id in buildingPowerStates) {
        colorExpr.push(id, POWER_COLORS[buildingPowerStates[id]]);
    }

    colorExpr.push(DEFAULT_COLOR);

    map.setPaintProperty(POWER_LAYER_ID, "fill-extrusion-color", colorExpr);
}

/* ---------------------- Click Handler ---------------------- */

function handleBuildingClick(e) {
    const remaining = CABLE_BUDGET - usedCableLength;
    if (remaining <= 0)
        return updateGameHUD("Budget exhausted!");

    const features = map.queryRenderedFeatures(e.point, { layers: [POWER_LAYER_ID] });
    if (!features.length) return;

    const clicked = features[0];
    const clickedID = clicked.properties.id;

    if (connectedBuildingIDs.has(clickedID)) {
        return updateGameHUD("That building is already powered.");
    }

    const sourceFeature = reprojectedFeatures.find(f => f.properties.id === currentConnectionTargetID);

    const srcCoords = getConnectionCoordinates(sourceFeature);
    const dstCoords = getConnectionCoordinates(clicked);

    if (!srcCoords || !dstCoords) {
        console.error("Null centroid:", { srcCoords, dstCoords });
        return updateGameHUD("Cannot get centroid (invalid building geometry).");
    }

    const dist = calculateDistance(srcCoords, dstCoords);

    if (dist > MAX_JUMP_DISTANCE)
        return updateGameHUD(`Too far: ${dist.toFixed(0)}m > ${MAX_JUMP_DISTANCE}m`);

    if (dist > remaining)
        return updateGameHUD(`Not enough cable! Need ${dist.toFixed(0)}m`);

    // SUCCESS
    usedCableLength += dist;
    connectedBuildingIDs.add(clickedID);
    buildingPowerStates[clickedID] = "ON";
    currentConnectionTargetID = clickedID;

    // draw line
    powerLineGeometry.features.push({
        type: "Feature",
        geometry: {
            type: "LineString",
            coordinates: [
                [srcCoords.lng, srcCoords.lat],
                [dstCoords.lng, dstCoords.lat]
            ]
        }
    });

    map.getSource("power-lines").setData(powerLineGeometry);
    updateBuildingColors();

    if (connectedBuildingIDs.size === totalBuildingsCount) {
        updateGameHUD("ðŸŽ‰ All buildings powered!");
        map.off("click", POWER_LAYER_ID, handleBuildingClick);
    } else {
        updateGameHUD(`Connected. Remaining cable: ${(CABLE_BUDGET - usedCableLength).toFixed(0)}m`);
    }
}

/* ---------------------- Map Init ---------------------- */

const map = new maplibregl.Map({
    style: "https://tiles.openfreemap.org/styles/positron",
    center: [-0.092, 51.515],
    zoom: 16,
    pitch: 60,
    bearing: -20,
    container: "map"
});

map.on("load", () => {
    fetch("https://mapsmania.github.io/globalbuilding/building.geojson")
        .then(r => r.json())
        .then(data => {

            data.features = data.features.map(f => ({
                ...f,
                geometry: reprojectGeometry(f.geometry)
            }));

            reprojectedFeatures = data.features;

            initializePowerStates(reprojectedFeatures);

            map.addSource("buildings", { type: "geojson", data });
            map.addLayer({
                id: POWER_LAYER_ID,
                type: "fill-extrusion",
                source: "buildings",
                paint: {
                    "fill-extrusion-color": DEFAULT_COLOR,
                    "fill-extrusion-height": ["coalesce", ["get", "height"], 10],
                    "fill-extrusion-opacity": 0.9
                }
            });

            map.addSource("power-lines", { type: "geojson", data: powerLineGeometry });
            map.addLayer({
                id: "connections-line",
                type: "line",
                source: "power-lines",
                paint: {
                    "line-color": "#00FF00",
                    "line-width": 4,
                    "line-opacity": 0.8
                }
            });

            updateBuildingColors();
            updateGameHUD("Click a nearby unpowered building.");

            map.on("click", POWER_LAYER_ID, handleBuildingClick);
            map.addControl(new maplibregl.NavigationControl());
        });
});
</script>

</body>
</html>

