<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Power Grid Routing Puzzle (Fixed Data Access)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://unpkg.com/maplibre-gl@3.4.0/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/maplibre-gl@3.4.0/dist/maplibre-gl.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
<style>
    body { margin: 0; padding: 0; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }
    
    /* Style for the Heads-Up Display (HUD) */
    #hud { 
        position: absolute; 
        top: 10px; 
        left: 10px; 
        background: rgba(0,0,0,0.8); 
        color: white; 
        padding: 15px; 
        border-radius: 8px;
        z-index: 10;
        font-family: sans-serif;
    }
    #hud h2 { margin-top: 0; font-size: 1.2em; }
    #hud p { margin: 5px 0; font-size: 1em; }
    .status-alert { color: yellow; font-weight: bold; }
</style>
</head>
<body>
<div id="hud">
    <h2>âš¡ Power Grid Puzzle</h2>
    <p>Connected Buildings: <span id="connected-count">0</span> / <span id="total-buildings">0</span></p>
    <p>Cable Used: <span id="used-cable">0</span> m</p>
    <p>Cable Budget: <span id="budget-remaining">0</span> m</p>
    <p class="status-alert" id="game-status"></p>
</div>
<div id="map"></div>

<script>
// --- CORE CONFIGURATION ---
const POWER_LAYER_ID = 'buildings-3d';
const POWER_COLORS = {
    'ON': '#FFFFB3',    // Warm light
    'OFF': '#1A1A1A'    // Darkness
};
const DEFAULT_COLOR = '#888888'; 

// Game Budget and Constraints
const CABLE_BUDGET = 10000; // Total meters of cable available
const MAX_JUMP_DISTANCE = 500; // Max meters for a single connection (Jump Constraint)

// Global State Tracking
let totalBuildingsCount = 0;
let reprojectedFeatures = []; // <-- THE NEW GLOBAL STORE FOR RELIABLE FEATURE ACCESS
let powerSourceID = null;
let currentConnectionTargetID = null; 
let usedCableLength = 0;
const buildingPowerStates = {}; 
const connectedBuildingIDs = new Set();
const powerLineGeometry = { type: 'FeatureCollection', features: [] }; 

// --- COORDINATE REPROJECTION ---
const proj3857 = proj4('EPSG:3857');
const proj4326 = proj4('EPSG:4326');

function reprojectCoord(coord) {
    return proj4(proj3857, proj4326, coord);
}

function reprojectGeometry(geom) {
    if (geom.type === "Polygon") {
        return { type: "Polygon", coordinates: geom.coordinates.map(ring => ring.map(reprojectCoord)) };
    }
    if (geom.type === "MultiPolygon") {
        return { type: "MultiPolygon", coordinates: geom.coordinates.map(poly => poly.map(ring => ring.map(reprojectCoord))) };
    }
    return geom;
}


// --- UTILITY FUNCTIONS ---

/**
 * Calculates the approximate distance between two LngLat coordinates.
 */
function calculateDistance(coord1, coord2) {
    const R = 6371000; // Radius of Earth in meters
    const dLat = (coord2.lat - coord1.lat) * (Math.PI / 180);
    const dLon = (coord2.lng - coord1.lng) * (Math.PI / 180);
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(coord1.lat * (Math.PI / 180)) * Math.cos(coord2.lat * (Math.PI / 180)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}

/**
 * Retrieves the connection point (approx. centroid) for a given building feature.
 * This is now safer as it relies on the pre-processed global feature array.
 */
function getConnectionCoordinates(feature) {
    const geom = feature.geometry;

    if (!geom || !geom.coordinates) return null;

    // Handle Polygon
    let ring = null;
    if (geom.type === "Polygon") {
        ring = geom.coordinates[0];
    } else if (geom.type === "MultiPolygon") {
        ring = geom.coordinates[0][0];
    } else {
        return null;
    }

    // Compute centroid of first ring
    let area = 0, x = 0, y = 0;

    for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        const [x1, y1] = ring[j];
        const [x2, y2] = ring[i];
        const f = x1 * y2 - x2 * y1;
        area += f;
        x += (x1 + x2) * f;
        y += (y1 + y2) * f;
    }

    area *= 0.5;

    if (area === 0) {
        // fallback: use first coordinate
        const [lng, lat] = ring[0];
        return { lng, lat };
    }

    const lng = x / (6 * area);
    const lat = y / (6 * area);

    return { lng, lat };
}

/**
 * Updates the visibility of the connected buildings and the HUD.
 */
function updateBuildingColors() {
    const colorExpression = ['match', ['get', 'id']];

    for (const id in buildingPowerStates) {
        colorExpression.push(id, POWER_COLORS[buildingPowerStates[id]]);
    }
    
    colorExpression.push(DEFAULT_COLOR);

    map.setPaintProperty(POWER_LAYER_ID, 'fill-extrusion-color', colorExpression);
    updateGameHUD();
}

/**
 * Updates the game's Heads-Up Display (HUD).
 */
function updateGameHUD(statusMessage = "Select the next nearest unlit building.") {
    const remainingCable = CABLE_BUDGET - usedCableLength;
    
    document.getElementById('connected-count').innerText = connectedBuildingIDs.size;
    document.getElementById('total-buildings').innerText = totalBuildingsCount;
    document.getElementById('used-cable').innerText = usedCableLength.toFixed(0);
    document.getElementById('budget-remaining').innerText = remainingCable.toFixed(0);
    document.getElementById('game-status').innerText = statusMessage;
    
    // Highlight if budget is low
    document.getElementById('budget-remaining').style.color = remainingCable < 1000 ? 'red' : 'lightgreen';
}


// --- GAME LOGIC ---

/**
 * Initializes the power state (all OFF except for one source).
 */
function initializePowerStates(features) {
    totalBuildingsCount = features.length;
    
    // 1. Set all buildings to 'OFF'
    features.forEach(f => {
        buildingPowerStates[f.properties.id] = 'OFF';
    });

    // 2. Select a random Source Node
    const randomIndex = Math.floor(Math.random() * features.length);
    const sourceBuilding = features[randomIndex];
    
    powerSourceID = sourceBuilding.properties.id;
    currentConnectionTargetID = powerSourceID;
    
    // 3. Turn the source ON
    buildingPowerStates[powerSourceID] = 'ON';
    connectedBuildingIDs.add(powerSourceID);
}


/**
 * Handles clicks on buildings to establish connections.
 */
function handleBuildingClick(e) {
    const remainingBudget = CABLE_BUDGET - usedCableLength;
    
    if (remainingBudget <= 0) {
        updateGameHUD("Budget Exhausted! Game Over.");
        return;
    }

    const features = map.queryRenderedFeatures(e.point, { layers: [POWER_LAYER_ID] });

    if (features.length > 0) {
        const clickedFeature = features[0];
        const clickedID = clickedFeature.properties.id;

        // --- Check 1: Must target an unlit building ---
        if (connectedBuildingIDs.has(clickedID)) {
            updateGameHUD("Building is already powered. Connect to an unlit neighbor.");
            return;
        }

        // --- Find Source Coordinates (FIXED RELIABLE ACCESS) ---
        const sourceFeature = reprojectedFeatures.find(f => f.properties.id === currentConnectionTargetID);
        
        if (!sourceFeature) {
             console.error("Source feature not found in global store. Cannot connect.");
             return;
        }

        const clickedCoordinates = getConnectionCoordinates(clickedFeature);
        const sourceCoordinates = getConnectionCoordinates(sourceFeature);
        
        const proposedLength = calculateDistance(sourceCoordinates, clickedCoordinates);
        
        // --- Constraint Check 2: Max Jump Distance Limit ---
        if (proposedLength > MAX_JUMP_DISTANCE) {
            updateGameHUD(`Connection failed! Path too long (${proposedLength.toFixed(0)}m). Limit: ${MAX_JUMP_DISTANCE}m.`);
            return;
        }

        // --- Constraint Check 3: CABLE BUDGET LIMIT ---
        if (proposedLength > remainingBudget) {
            updateGameHUD(`Connection failed! Proposed length (${proposedLength.toFixed(0)}m) exceeds remaining budget of ${remainingBudget.toFixed(0)}m. Max buildings connected.`);
            return;
        }
        
        // --- SUCCESSFUL CONNECTION ---
        
        // 1. Update Game State & Budget
        usedCableLength += proposedLength; 
        connectedBuildingIDs.add(clickedID);
        buildingPowerStates[clickedID] = 'ON';
        currentConnectionTargetID = clickedID; 
        
        // 2. Add Line Segment
        const newLineFeature = {
            type: 'Feature',
            geometry: {
                type: 'LineString',
                coordinates: [
                    [sourceCoordinates.lng, sourceCoordinates.lat],
                    [clickedCoordinates.lng, clickedCoordinates.lat]
                ]
            }
        };
        powerLineGeometry.features.push(newLineFeature);

        // 3. Update the Map & HUD
        map.getSource('power-lines').setData(powerLineGeometry);
        updateBuildingColors(); 

        // 4. Check Win Condition
        if (connectedBuildingIDs.size === totalBuildingsCount) {
            updateGameHUD(`ðŸŽ‰ All ${totalBuildingsCount} Buildings Powered! Total Cable Used: ${usedCableLength.toFixed(0)}m.`);
            map.off('click', POWER_LAYER_ID, handleBuildingClick); 
        } else {
            updateGameHUD(`Cable Used: ${usedCableLength.toFixed(0)}m. Budget Remaining: ${remainingBudget.toFixed(0)}m. Keep connecting!`);
        }
    }
}


// --- MAP INITIALIZATION ---

const map = new maplibregl.Map({
    style: 'https://tiles.openfreemap.org/styles/positron',
    center: [-0.092, 51.515],
    zoom: 16,
    pitch: 60,
    bearing: -20,
    container: 'map',
});
  
map.on('load', () => {
    fetch("https://mapsmania.github.io/globalbuilding/building.geojson")
        .then(r => r.json())
        .then(data => {
            // Reproject all features
            data.features = data.features.map(f => ({
                ...f,
                geometry: reprojectGeometry(f.geometry)
            }));

            // Store the reprojected features globally for reliable access later
            reprojectedFeatures = data.features;

            // Initialize game state (find source, set others OFF)
            initializePowerStates(reprojectedFeatures);

            // 1. Add Buildings Source and Layer
            map.addSource('buildings', { type: 'geojson', data: data });
            map.addLayer({
                id: POWER_LAYER_ID,
                type: 'fill-extrusion',
                source: 'buildings',
                paint: {
                    'fill-extrusion-color': DEFAULT_COLOR, 
                    'fill-extrusion-height': ['coalesce', ['get', 'height'], 10],
                    'fill-extrusion-base': 0,
                    'fill-extrusion-opacity': 0.9
                }
            });

            // 2. Add Power Lines Source and Layer
            map.addSource('power-lines', { type: 'geojson', data: powerLineGeometry });
            map.addLayer({
                id: 'connections-line',
                type: 'line',
                source: 'power-lines',
                paint: {
                    'line-color': '#00FF00', // Bright green for the power line
                    'line-width': 4,
                    'line-opacity': 0.8
                }
            });

            // Set the initial colors and HUD
            updateBuildingColors();
            updateGameHUD();

            // Add interactivity and controls
            map.on('click', POWER_LAYER_ID, handleBuildingClick);
            map.addControl(new maplibregl.NavigationControl());
        });
});
</script>
</body>
</html>
